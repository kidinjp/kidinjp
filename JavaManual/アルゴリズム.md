概要
* [ソートアルゴリズム](#ソートアルゴリズム)
* [検索アルゴリズム](#検索アルゴリズム)
* [動的計画法](#動的計画法)
* [グラフアルゴリズム](#グラフアルゴリズム)

***************************************************************************
## ソートアルゴリズム
**クイックソート**  
クイックソートは分割統治法に基づく効率的なソートアルゴリズム

```Java
import java.util.Arrays;

public class Main {
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = (low - 1);
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        return i + 1;
    }

    public static void main(String[] args) {
        int[] arr = {10, 7, 8, 9, 1, 5};
        quickSort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }
}
```

***************************************************************************
## 検索アルゴリズム
**バイナリサーチ（2分探索）**  
ソート済み配列での効率的な検索

```Java
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] arr = {1, 3, 5, 7, 9, 11, 13};
        int key = 7;
        int result = Arrays.binarySearch(arr, key);
        if (result >= 0) {
            System.out.println("Found at index: " + result);
        } else {
            System.out.println("Not found");
        }
    }
}
```

***************************************************************************
## 動的計画法
**ナップサック問題**  
動的計画法を用いて、最大価値を求める

```Java
public class Main {
    public static int knapsack(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        int[][] dp = new int[n + 1][capacity + 1];

        for (int i = 1; i <= n; i++) {
            for (int w = 0; w <= capacity; w++) {
                if (weights[i - 1] <= w) {
                    dp[i][w] = Math.max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);
                } else {
                    dp[i][w] = dp[i - 1][w];
                }
            }
        }
        return dp[n][capacity];
    }

    public static void main(String[] args) {
        int[] weights = {1, 2, 3};
        int[] values = {6, 10, 12};
        int capacity = 5;
        System.out.println("Maximum value: " + knapsack(weights, values, capacity));
    }
}
```

***************************************************************************
## グラフアルゴリズム
**ダイクストラ法**  
単一始点の最短経路を求める

```Java
import java.util.*;

public class Main {
    static class Edge {
        int target, weight;

        public Edge(int target, int weight) {
            this.target = target;
            this.weight = weight;
        }
    }

    public static void dijkstra(List<List<Edge>> graph, int src) {
        int n = graph.size();
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[src] = 0;

        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));
        pq.offer(new int[]{src, 0});

        while (!pq.isEmpty()) {
            int[] current = pq.poll();
            int node = current[0], d = current[1];

            if (d > dist[node]) continue;

            for (Edge edge : graph.get(node)) {
                int newDist = dist[node] + edge.weight;
                if (newDist < dist[edge.target]) {
                    dist[edge.target] = newDist;
                    pq.offer(new int[]{edge.target, newDist});
                }
            }
        }

        System.out.println("Shortest distances: " + Arrays.toString(dist));
    }

    public static void main(String[] args) {
        List<List<Edge>> graph = new ArrayList<>();
        for (int i = 0; i < 5; i++) graph.add(new ArrayList<>());
```

### 巡回セールスマン
全列挙で、全パターンのルートを巡回する  
最終出力内容：最短距離、該距離のルート
```
【入力される値】
n
x_0 y_0
x_1 y_1
...
x_{n-1} y_{n-1}
・ 1 行目に都市の個数 n が与えられます。
・ 続く n 行のうち i (1 ≦ i ≦ n) 行目には、都市 i-1 の座標が半角スペース区切りで与えられます。

【期待する出力】
1 行目に巡回路長の最小値を出力してください。絶対誤差が 10^-6 以下なら正解と判定されます。
2 行目に巡回路長が最小となるような巡回路を出力してください。巡回路は、都市番号 (0, 1, ... , n-1) の順列で表し、半角スペース区切りで出力してください。

【条件】
すべてのテストケースにおいて、以下の条件をみたします。
・ 入力はすべて整数
・ 2 ≦ n ≦ 16
・ -1,000 ≦ x_i, y_i ≦ 1,000 (0 ≦ i ≦ n-1)
・ i ≠ j ならば (x_i, y_i) ≠ (x_j, y_j)

【入力例1】
4
0 0
2 2
-1 1
0 -2

【出力例1】
11.048627177541
1 3 0 2
```

実際のコード：
```Java
import java.util.*;


public class Main {
    // ユークリッド距離
    public static double kyouri (int[] xy_1, int[] xy_2) {
        return Math.sqrt(Math.pow(xy_1[0] - xy_2[0], 2) + Math.pow(xy_1[1] - xy_2[1], 2));
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] xy = new int[n][2];
        double[][] distance = new double[n][n];
        for (int i = 0; i < n; i++) {
            xy[i][0] = sc.nextInt();
            xy[i][1] = sc.nextInt();
            for (int j = 0; j < i; j++) {
                double k = kyouri(xy[i], xy[j]);
                distance[i][j] = k;
                distance[j][i] = k;
            }
        }
        
        // 動的計画法テーブル
        // dp[i][mask]: 都市0から出発し、maskに含まれる都市を訪問後に都市iに到達する最短距離
        double[][] dp = new double[n][1 << n];
        for (int i = 0; i < n; i++) Arrays.fill(dp[i], Double.MAX_VALUE);
        // 初期化: 都市0から各都市への距離
        dp[0][1] = 0;
        
        // 遷移を記録するテーブル
        int[][] before = new int[n][1 << n]; 
        
        
        // 集合mask（訪問済み都市のビット表現）を増やしながら解を計算
        for (int mask = 1; mask < (1 << n); mask++) {
            for (int i = 0; i < n; i++) {
                if ((mask & (1 << i)) == 0)  continue; // 都市iが集合に含まれていない
        
                for (int j = 0; j < n; j++) {
                    if ((mask & (1 << j)) != 0) continue; // 都市jが集合に含まれている
        
                    int nextMask = mask | (1 << j);
                    // 遷移を更新: 都市iから都市jに移動した場合の距離を計算
                    double newDist = dp[i][mask] + distance[i][j];
                    if (newDist < dp[j][nextMask]) {
                        dp[j][nextMask] = newDist;
                        before[j][nextMask] = i; // 遷移元を記録
                    }

                }
            }
        }
        
        double result = Double.MAX_VALUE;
        int lastCity = -1; // 最後に訪問する都市 
        for (int i = 1; i < n; i++) {
            // dp[i][(1 << n) - 1]: 全都市訪問後に都市iにいる場合の最短距離
            // distance[i][0]: 都市iから都市0への距離
            double cost = dp[i][(1 << n) - 1] + distance[i][0];
            if (cost < result) {
                result = cost;
                lastCity = i;
            }
        }

        // 巡回路を復元
        int[] tour = new int[n];
        int mask = (1 << n) - 1;
        int current = lastCity;
        for (int i = n - 1; i >= 0; i--) {
            tour[i] = current; // 都市を逆順に記録
            int prev = before[current][mask];
            mask ^= (1 << current); // 現在の都市を集合から外す
            current = prev;
        }

        System.out.println(result);
        for (int i = 0; i < n - 1; i++) {
            System.out.print(tour[i] + " ");
        }
        System.out.println(tour[n - 1]);
        
    }
}
```

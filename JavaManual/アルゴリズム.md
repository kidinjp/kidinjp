概要
* [ソートアルゴリズム](#ソートアルゴリズム)
* [検索アルゴリズム](#検索アルゴリズム)
* [動的計画法](#動的計画法)
* [グラフアルゴリズム](#グラフアルゴリズム)
* [巡回セールスマン(TSP)](#巡回セールスマンtsp)
    * [クラスカル法による最小全域木 (MST)](#クラスカル法による最小全域木-mst)
    * [最近傍法によるTSP](#最近傍法によるtsp)
    * [Union-Findクラスの作成](##union-findクラスの作成)

***************************************************************************
## ソートアルゴリズム
**クイックソート**  
クイックソートは分割統治法に基づく効率的なソートアルゴリズム

```Java
import java.util.Arrays;

public class Main {
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = (low - 1);
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        return i + 1;
    }

    public static void main(String[] args) {
        int[] arr = {10, 7, 8, 9, 1, 5};
        quickSort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }
}
```

***************************************************************************
## 検索アルゴリズム
**バイナリサーチ（2分探索）**  
ソート済み配列での効率的な検索

```Java
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] arr = {1, 3, 5, 7, 9, 11, 13};
        int key = 7;
        int result = Arrays.binarySearch(arr, key);
        if (result >= 0) {
            System.out.println("Found at index: " + result);
        } else {
            System.out.println("Not found");
        }
    }
}
```

***************************************************************************
## 動的計画法
**ナップサック問題**  
動的計画法を用いて、最大価値を求める

```Java
public class Main {
    public static int knapsack(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        int[][] dp = new int[n + 1][capacity + 1];

        for (int i = 1; i <= n; i++) {
            for (int w = 0; w <= capacity; w++) {
                if (weights[i - 1] <= w) {
                    dp[i][w] = Math.max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);
                } else {
                    dp[i][w] = dp[i - 1][w];
                }
            }
        }
        return dp[n][capacity];
    }

    public static void main(String[] args) {
        int[] weights = {1, 2, 3};
        int[] values = {6, 10, 12};
        int capacity = 5;
        System.out.println("Maximum value: " + knapsack(weights, values, capacity));
    }
}
```

***************************************************************************
## グラフアルゴリズム
**ダイクストラ法**  
単一始点の最短経路を求める

```Java
import java.util.*;

public class Main {
    static class Edge {
        int target, weight;

        public Edge(int target, int weight) {
            this.target = target;
            this.weight = weight;
        }
    }

    public static void dijkstra(List<List<Edge>> graph, int src) {
        int n = graph.size();
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[src] = 0;

        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));
        pq.offer(new int[]{src, 0});

        while (!pq.isEmpty()) {
            int[] current = pq.poll();
            int node = current[0], d = current[1];

            if (d > dist[node]) continue;

            for (Edge edge : graph.get(node)) {
                int newDist = dist[node] + edge.weight;
                if (newDist < dist[edge.target]) {
                    dist[edge.target] = newDist;
                    pq.offer(new int[]{edge.target, newDist});
                }
            }
        }

        System.out.println("Shortest distances: " + Arrays.toString(dist));
    }

    public static void main(String[] args) {
        List<List<Edge>> graph = new ArrayList<>();
        for (int i = 0; i < 5; i++) graph.add(new ArrayList<>());
```

## 巡回セールスマン(TSP)
全列挙で、全パターンのルートを巡回する  
最終出力内容：最短距離、該距離のルート
```
【入力される値】
n
x_0 y_0
x_1 y_1
...
x_{n-1} y_{n-1}
・ 1 行目に都市の個数 n が与えられます。
・ 続く n 行のうち i (1 ≦ i ≦ n) 行目には、都市 i-1 の座標が半角スペース区切りで与えられます。

【期待する出力】
1 行目に巡回路長の最小値を出力してください。絶対誤差が 10^-6 以下なら正解と判定されます。
2 行目に巡回路長が最小となるような巡回路を出力してください。巡回路は、都市番号 (0, 1, ... , n-1) の順列で表し、半角スペース区切りで出力してください。

【条件】
すべてのテストケースにおいて、以下の条件をみたします。
・ 入力はすべて整数
・ 2 ≦ n ≦ 16
・ -1,000 ≦ x_i, y_i ≦ 1,000 (0 ≦ i ≦ n-1)
・ i ≠ j ならば (x_i, y_i) ≠ (x_j, y_j)

【入力例1】
4
0 0
2 2
-1 1
0 -2

【出力例1】
11.048627177541
1 3 0 2
```

実際のコード：
```Java
import java.util.*;


public class Main {
    // ユークリッド距離
    public static double kyouri (int[] xy_1, int[] xy_2) {
        return Math.sqrt(Math.pow(xy_1[0] - xy_2[0], 2) + Math.pow(xy_1[1] - xy_2[1], 2));
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] xy = new int[n][2];
        double[][] distance = new double[n][n];
        for (int i = 0; i < n; i++) {
            xy[i][0] = sc.nextInt();
            xy[i][1] = sc.nextInt();
            for (int j = 0; j < i; j++) {
                double k = kyouri(xy[i], xy[j]);
                distance[i][j] = k;
                distance[j][i] = k;
            }
        }
        
        // 動的計画法テーブル
        // dp[i][mask]: 都市0から出発し、maskに含まれる都市を訪問後に都市iに到達する最短距離
        double[][] dp = new double[n][1 << n];
        for (int i = 0; i < n; i++) Arrays.fill(dp[i], Double.MAX_VALUE);
        // 初期化: 都市0から各都市への距離
        dp[0][1] = 0;
        
        // 遷移を記録するテーブル
        int[][] before = new int[n][1 << n]; 
        
        
        // 集合mask（訪問済み都市のビット表現）を増やしながら解を計算
        for (int mask = 1; mask < (1 << n); mask++) {
            for (int i = 0; i < n; i++) {
                if ((mask & (1 << i)) == 0)  continue; // 都市iが集合に含まれていない
        
                for (int j = 0; j < n; j++) {
                    if ((mask & (1 << j)) != 0) continue; // 都市jが集合に含まれている
        
                    int nextMask = mask | (1 << j);
                    // 遷移を更新: 都市iから都市jに移動した場合の距離を計算
                    double newDist = dp[i][mask] + distance[i][j];
                    if (newDist < dp[j][nextMask]) {
                        dp[j][nextMask] = newDist;
                        before[j][nextMask] = i; // 遷移元を記録
                    }

                }
            }
        }
        
        double result = Double.MAX_VALUE;
        int lastCity = -1; // 最後に訪問する都市 
        for (int i = 1; i < n; i++) {
            // dp[i][(1 << n) - 1]: 全都市訪問後に都市iにいる場合の最短距離
            // distance[i][0]: 都市iから都市0への距離
            double cost = dp[i][(1 << n) - 1] + distance[i][0];
            if (cost < result) {
                result = cost;
                lastCity = i;
            }
        }

        // 巡回路を復元
        int[] tour = new int[n];
        int mask = (1 << n) - 1;
        int current = lastCity;
        for (int i = n - 1; i >= 0; i--) {
            tour[i] = current; // 都市を逆順に記録
            int prev = before[current][mask];
            mask ^= (1 << current); // 現在の都市を集合から外す
            current = prev;
        }

        System.out.println(result);
        for (int i = 0; i < n - 1; i++) {
            System.out.print(tour[i] + " ");
        }
        System.out.println(tour[n - 1]);
        
    }
}
```

### クラスカル法による最小全域木 (MST) 
Kruskal法は、グラフの全ての頂点を含みつつ、辺の重みの合計が最小になるように辺を選択するアルゴリズム  
このアルゴリズムは「**貪欲法**」に基づいており、以下のような手順で進行する  
* **貪欲法**: 「最も軽い辺を選ぶ」という方針を繰り返すことで、全体の重みを最小にする
* **Union-Find**: サイクルを防ぎつつ、効率的にグループ管理を行う

* **全域木 (Spanning Tree)**: グラフのすべての頂点を1本の連結な木として含む部分グラフ
* **最小全域木 (MST)**: 重みの合計が最小の全域木
* **Kruskal法の鍵**: 軽い辺を選び、サイクルを避けることにより、最適な木を構築する

1. すべての辺を重み順に並べ【コスト、辺A、辺Bなど】（コストを昇順でソート）
2. 頂点を管理するためのデータ構造を初期化  
各頂点は独立したグループ（木）に属しているとみなし、それを管理するためにUnion-Find（もしくはDisjoint Set Union, DSU）というデータ構造を用意する
    * 各頂点がどのグループ（木）に属しているかを追跡する
    * Union-Findには次の2つの操作が含まれる：
        * find(x): 頂点 x がどのグループに属しているかを調べる
        * union(x, y): 頂点 x と y を同じグループに統合する
3. 重みが小さい辺から順に処理  
ソートした辺を1本ずつ検討し、以下の条件に基づいて選択する：
    * 辺が異なるグループ（木）を結んでいる場合、その辺を選択する
      この選択によって、2つのグループが1つに統合されます（union操作）。
    * 辺が同じグループ内の頂点を結んでいる場合、その辺は選択しない。これにより閉路（サイクル）の形成を防ぐ
4. MSTが完成するまで繰り返す  
辺の選択を繰り返し、選択した辺の数が「頂点数 - 1」になると、MSTが完成する

* 流れをまとめ：  
`辺のリストを作成し、距離でソート`　⇒  
`Union-Findで親ノードを初期化`　⇒  
`重みが小さい順に辺を検討`　⇒  
`MSTの完成`
```Java
import java.util.*;

public class Main {
    public static double[][] distance; // 各都市間の距離を保存する配列
    public static int[] parent; // Union-Findで使用する親配列
    public static List<int[]> mstEdges; // 最小全域木(MST)に含まれる辺を保存するリスト

    // ユークリッド距離を計算する関数
    public static double kyouri(int[] xy1, int[] xy2) {
        return Math.sqrt(Math.pow(xy1[0] - xy2[0], 2) + Math.pow(xy1[1] - xy2[1], 2));
    }

    // Kruskal法で最小全域木を構築
    public static void kruskal(int n) {
        // 優先度付きキューを使用して全ての辺を重み順に管理する
        PriorityQueue<double[]> edges = new PriorityQueue<>(Comparator.comparingDouble(a -> a[0]));

        // 全ての都市の組み合わせについて距離を計算し、辺として優先度付きキューに追加
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                edges.add(new double[]{distance[i][j], i, j}); // {距離, 頂点1, 頂点2}
            }
        }

        // Union-Findの親配列を初期化（各頂点が自分自身を親とする）
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }

        mstEdges = new ArrayList<>(); // MSTに含まれる辺を保存するリストを初期化

        // 重みが小さい順に辺を選択
        while (!edges.isEmpty() && mstEdges.size() < n - 1) {
            double[] edge = edges.poll(); // 最も軽い辺を取り出す
            int u = (int) edge[1]; // 辺の片方の頂点
            int v = (int) edge[2]; // 辺のもう片方の頂点

            // 異なるグループ（木）に属している場合、その辺を選択
            if (findSet(u) != findSet(v)) {
                unionSets(u, v); // 2つのグループを統合
                mstEdges.add(new int[]{u, v}); // 選択した辺をリストに追加
            }
        }
    }

    // Union-Find: 頂点の属するグループを見つける
    public static int findSet(int x) {
        if (parent[x] == x) return x; // 自分自身が親なら、そのまま返す
        parent[x] = findSet(parent[x]); // 経路圧縮を行う
        return parent[x];
    }

    // Union-Find: 2つのグループを統合する
    public static void unionSets(int x, int y) {
        int rootX = findSet(x);
        int rootY = findSet(y);
        if (rootX != rootY) {
            parent[rootX] = rootY; // rootXをrootYに繋げる
        }
    }

    // 深さ優先探索(DFS)で経路を生成
    public static void dfs(int node, boolean[] visited, List<Integer> tour) {
        visited[node] = true; // 現在の頂点を訪問済みにする
        tour.add(node); // 経路に現在の頂点を追加

        // MSTの辺をたどり、次の未訪問の頂点に移動
        for (int[] edge : mstEdges) {
            if (edge[0] == node && !visited[edge[1]]) {
                dfs(edge[1], visited, tour); // 隣接する頂点を再帰的に探索
            } else if (edge[1] == node && !visited[edge[0]]) {
                dfs(edge[0], visited, tour); // 隣接する頂点を再帰的に探索
            }
        }
    }

    // 近似的な巡回セールスマン問題の解を求める
    public static void approximateTSP(int n) {
        kruskal(n); // 最小全域木を構築

        List<Integer> tour = new ArrayList<>(); // 巡回経路を保存するリスト
        boolean[] visited = new boolean[n]; // 各頂点の訪問状態を管理
        dfs(0, visited, tour); // 深さ優先探索で巡回経路を生成

        // 巡回経路を出力
        for (int i = 0; i < tour.size(); i++) {
            System.out.print(tour.get(i) + (i < tour.size() - 1 ? " " : "\n"));
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 都市の数を入力
        int[][] xy = new int[n][2]; // 各都市の座標を保存
        distance = new double[n][n]; // 各都市間の距離を保存する配列

        // 各都市の座標を読み取り、距離を計算
        for (int i = 0; i < n; i++) {
            xy[i][0] = sc.nextInt(); // x座標
            xy[i][1] = sc.nextInt(); // y座標
            for (int j = 0; j < i; j++) {
                double dist = kyouri(xy[i], xy[j]); // ユークリッド距離を計算
                distance[i][j] = dist; // 距離を保存
                distance[j][i] = dist; // 距離は対称
            }
        }

        approximateTSP(n); // 近似的な巡回セールスマン問題を解く
    }
}
```

### 最近傍法によるTSP
1. 始点となる都市を適当に 1 つ選ぶ
2. すべての都市を訪れるまで、以下を繰り返す：
      * 今までに訪れたことのない都市のうち、`今いる都市に最も近い都市`を訪れる
3. 最後に始点へと戻る

* 始点として都市 0 を用いている
* 最も近い都市が複数がある場合、番号が小さい順で
```Java
import java.util.*;

public class Main {
    public static double[][] distance; // 各都市間の距離を保存する配列
    public static int[] parent; // Union-Findで使用する親配列
    public static List<int[]> mstEdges; // 最小全域木(MST)に含まれる辺を保存するリスト

    // ユークリッド距離を計算する関数
    public static double kyouri(int[] xy1, int[] xy2) {
        return Math.sqrt(Math.pow(xy1[0] - xy2[0], 2) + Math.pow(xy1[1] - xy2[1], 2));
    }

    // 最近傍法によるTSP
    // 今までに訪れたことのない都市のうち、今いる都市に最も近い都市を訪れる
    public static int moyori (int n, int ima, boolean[] sumi) {
        int kotae = -1;
        double kotae_distance = Double.MAX_VALUE;
        for (int i = 1; i < n; i++) {
            if (sumi[i]) continue;
            if (distance[ima][i] < kotae_distance) {
                kotae = i;
                kotae_distance = distance[ima][i];
            }
        }
        return kotae;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 都市の数を入力
        int[][] xy = new int[n][2]; // 各都市の座標を保存
        distance = new double[n][n]; // 各都市間の距離を保存する配列

        // 各都市の座標を読み取り、距離を計算
        for (int i = 0; i < n; i++) {
            xy[i][0] = sc.nextInt(); // x座標
            xy[i][1] = sc.nextInt(); // y座標
            for (int j = 0; j < i; j++) {
                double dist = kyouri(xy[i], xy[j]); // ユークリッド距離を計算
                distance[i][j] = dist; // 距離を保存
                distance[j][i] = dist; // 距離は対称
            }
        }
        
        // 最近傍法
        boolean[] sumi = new boolean[n];
        sumi[0] = true;
        int turn = 1;
        int ima = 0;
        System.out.println(ima);
        while (turn < n) {
            ima = moyori(n, ima, sumi);
            turn++;
            sumi[ima] = true;
            System.out.println(ima);
            
        }
        
    }
}
```


#### Union-Findクラスの作成
```Java
import java.util.*;

public class Main {
    // ユークリッド距離を計算する関数
    public static double dist(double[] a, double[] b) {
        return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));
    }

    // Union-Findクラス
    static class UnionFind {
        private int[] parent;

        public UnionFind(int n) {
            parent = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i; // 初期状態では各要素が自分自身を親とする
            }
        }

        // 親を見つけるメソッド
        public int getParent(int a) {
            if (a != parent[a]) {
                parent[a] = getParent(parent[a]); // 経路圧縮を行う
            }
            return parent[a];
        }

        // 二つの要素を連結するメソッド
        public void unite(int a, int b) {
            int rootA = getParent(a);
            int rootB = getParent(b);
            parent[rootB] = rootA; // 一方の親をもう一方に繋げる
        }

        // 二つの要素が同じ集合に属するかを判定するメソッド
        public boolean same(int a, int b) {
            return getParent(a) == getParent(b);
        }
    }

    // 貪欲法で巡回路を生成する関数
    public static List<Integer> scan(int n, List<List<Integer>> edges) {
        int start = -1;
        // スタート地点を見つける
        for (int i = 0; i < n; i++) {
            if (edges.get(i).size() == 1) {
                start = i;
                break;
            }
        }

        // 巡回路を生成
        List<Integer> tour = new ArrayList<>();
        tour.add(start);
        tour.add(edges.get(start).get(0));

        for (int i = 2; i < n; i++) {
            List<Integer> lastNodeEdges = edges.get(tour.get(tour.size() - 1));
            for (int next : lastNodeEdges) {
                if (next != tour.get(tour.size() - 2)) {
                    tour.add(next);
                    break;
                }
            }
        }
        return tour;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 点の数
        double[][] points = new double[n][2]; // 各点の座標
        for (int i = 0; i < n; i++) {
            points[i][0] = sc.nextDouble(); // x座標
            points[i][1] = sc.nextDouble(); // y座標
        }

        List<double[]> edges = new ArrayList<>();
        // 全ての点の組み合わせについて距離を計算して辺を追加
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                edges.add(new double[]{dist(points[i], points[j]), i, j});
            }
        }

        // 辺を重み(距離)の昇順でソート
        edges.sort(Comparator.comparingDouble(a -> a[0]));

        UnionFind uf = new UnionFind(n);
        List<List<Integer>> visited = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            visited.add(new ArrayList<>()); // 各点に対応する訪問リストを初期化
        }

        // Kruskal法で辺を選択
        for (double[] edge : edges) {
            int i = (int) edge[1];
            int j = (int) edge[2];
            if (uf.same(i, j) || visited.get(i).size() == 2 || visited.get(j).size() == 2) {
                continue; // 同じ集合に属している場合や既に2つの辺が存在する場合はスキップ
            }
            visited.get(i).add(j); // エッジを追加
            visited.get(j).add(i); // エッジを追加
            uf.unite(i, j); // Union-Findで連結
        }

        // 貪欲法で巡回路を生成
        List<Integer> tour = scan(n, visited);

        // 結果を出力
        for (int i = 0; i < tour.size(); i++) {
            System.out.println(tour.get(i));
        }
    }
}
```



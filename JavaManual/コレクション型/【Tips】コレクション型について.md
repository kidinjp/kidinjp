概要
* [コレクション型とは](#コレクション型とは)
* [List(リスト)](#listリスト)
* [Set(セット)](#setセット)
* [Queue(キュー)](#queueキュー)
* [Stack(スタック)](#stackスタック)
* [Deque(デック)](#dequeデック)
* [Map(マップ)](#mapマップ)
***************************************************************************
## コレクション型とは
* コレクション型は、複数の要素を一つのオブジェクトとして管理できるデータ構造のこと
* Javaでは、これを管理するための`インターフェース`や`クラス`が `java.util` パッケージに提供されている
* コレクション型を使うことで、複数のデータを効率的に扱えるようになる
* コレクションを操作するために、Collections クラスやStream API（Java 8以降）が用意されている

| インターフェイス | 説明 | 主な実装クラス |
| --- | --- | --- |
| List | データ項目に順序付けしたコレクションで、順序付けて要素を管理する<br>リストの中の要素は重複しても良い | ArrayList<br>LinkedList<br>Vector |
| Set | ユニークな値のコレクションで、順不同で要素を管理する<br>重複した要素は管理できない | HashSet<br>LinkedHashSet<br>TreeSet |
| Queue | FIFO(First-In-First-Out)形式のデータ入出力を行うコレクション | ArrayDeque<br>LinkedList<br>PriorityQueue |
| Stack | LIFO(Last-In-First-Out)形式でデータ入出力を行うコレクション | Stack |
| Deque | 両端キューで、FIFOまたはLIFOで要素を操作できるコレクション | ArrayDeque<br>LinkedList |
| Map | 個々のキーに対応する値をマップしたオブジェクトで、1つのキーに一つの値が割り当てられる<br>マップの中でキーは重複できないが、値は重複できる | HashMap<br>LinkedHashMap<br>TreeMap |

***************************************************************************
## List(リスト)
* **順序付きのコレクション**：リストに格納された要素は挿入された順番を保持する
* **重複を許可**：同じ要素を何度でも格納できる
* **主な実装クラス**：
  * ArrayList：動的配列で、**ランダムアクセスが高速**、要素の挿入・削除は遅い場合がある
  * LinkedList：双方向リストで、挿入・削除が高速だが、ランダムアクセスは遅い
  * Vector：同期化された動的配列。古い実装で、現在ではあまり使われない

| 特徴 | ArrayList | LinkedList | Vector |
| --- | --- | --- | --- |
| **順序** | 挿入順を保持 | 挿入順を保持 | 挿入順を保持 |
| **速度** | ランダムアクセスが高速（O(1)） | 挿入・削除は両端で高速（O(1）<br>中央操作は O(n) | ランダムアクセスが高速（O(1)） |
| **メモリ効率** | 配列ベースで効率的 | 各要素がノードを持つためオーバーヘッドが高い | 配列ベースで効率的（ただし同期化のコストあり） |
| **同期化** | 同期化されていない | 同期化されていない | 同期化されている |
| **データ構造** | 動的配列 | 双方向リンクリスト | 動的配列 |
| **使用場面** | ランダムアクセスが多い場合 | 頻繁な挿入・削除がある場合 | マルチスレッド環境でランダムアクセスが必要な場合 |
| **サポート機能** | リスト操作<br>ランダムアクセス | リスト操作<br>両端操作<br>スタック操作も可能 | リスト操作<br>スレッドセーフ |

* その他実装クラス：
  * CopyOnWriteArrayList：読み取り操作が多い場合に最適なスレッドセーフなリスト
  * UnmodifiableList：読み取り専用のリスト
  * SynchronizedList：スレッドセーフなリスト
  * ImmutableList：外部ライブラリによる不変リスト

***************************************************************************
## Set(セット)
* **順序なし**
* **重複なし**：要素が順不同で格納され、重複する要素は格納できない
* **主な実装クラス**：
  * HashSet：ハッシュテーブルを使った実装で、**順序を保証しない**が、高速
  * LinkedHashSet：順序を保持し、**挿入順**に要素が格納される
  * TreeSet：木構造を使った実装で、要素が**自然順序**（**比較順序**）で格納される
 
| 特徴 | HashSet | LinkedHashSet | TreeSet |
| --- | --- | --- | --- |
| **順序** | 挿入順を保持 | 挿入順を保持 | 挿入順を保持 |
| **速度** | ランダムアクセスが高速（O(1)） | 挿入・削除は両端で高速（O(1）<br>中央操作は O(n) | ランダムアクセスが高速（O(1)） |
| **メモリ効率** | 配列ベースで効率的 | 各要素がノードを持つためオーバーヘッドが高い | 配列ベースで効率的（ただし同期化のコストあり） |
| **同期化** | 同期化されていない | 同期化されていない | 同期化されている |
| **データ構造** | 動的配列 | 双方向リンクリスト | 動的配列 |
| **使用場面** | ランダムアクセスが多い場合 | 頻繁な挿入・削除がある場合 | マルチスレッド環境でランダムアクセスが必要な場合 |
| **サポート機能** | リスト操作<br>ランダムアクセス | リスト操作<br>両端操作<br>スタック操作も可能 | リスト操作<br>スレッドセーフ |

***************************************************************************
## Queue(キュー)
* **FIFO（First-In-First-Out）**：先に入れた要素が先に取り出される
* **主な実装クラス**：
  * LinkedList（Queueインターフェースの実装）
  * PriorityQueue：要素に優先度を設定して、最も**優先度の高い要素を最初に取り出す**

| 特徴 | LinkedList | PriorityQueue |
| --- | --- | --- |
| **順序** | 挿入順を保持 | 優先順位に基づいて要素を並べる（自然順序または比較順序） |
| **速度** | 挿入・削除は O(1)（両端の場合）<br>中央操作は O(n) | 挿入・削除は O(log n) |
| **メモリ効率** | 各要素にノードが必要なため、オーバーヘッドが高い | 配列ベースで効率的 |
| **データ構造** | 双方向リンクリスト | ヒープ（Heap） |
| **使用場面** | 順序を維持したい場合や、双方向操作が必要な場合 | 優先順位に基づいた要素処理が必要な場合 |
| **サポート機能** | キュー（Queue）<br>スタック（Stack）<br>Deque | 優先順位キュー操作（offer, poll, peek） |
```Java
Queue<String> queue = new LinkedList<>();
queue.add("Apple");
queue.add("Banana");
queue.poll();  // "Apple"が取り出される
```

***************************************************************************
## Stack(スタック)
* **LIFO 構造（Last In, First Out）**：後に入れた要素が先に取り出される
* **主な実装クラス**：
  * Stack：従来のスタック実装クラス。後入れ先出しのデータ構造
  * ArrayDeque：Dequeとしても使えるため、スタック操作に適している

| 特徴 | Stack | ArrayDeque |
| --- | --- | --- |
| **順序** | 挿入順を保持 | 挿入順を保持 |
| **速度** | やや遅い（Vector ベースで同期化されている） | 高速（O(1)：両端操作） |
| **メモリ効率** | Vector ベースでオーバーヘッドが大きい | 配列ベースでメモリ効率が良い |
| **データ構造** | レガシーなクラス（Vector を継承） | 動的配列 |
| **使用場面** | 同期化が必要でスタック操作が中心の場合 | 両端キュー、スタック操作が多い場合 |
| **サポート機能** | スタック操作（LIFO：push, pop, peek） | キュー（Queue）/スタック（Stack） |

```Java
Stack<String> stack = new Stack<>();
stack.push("Apple");
stack.push("Banana");
stack.pop();  // "Banana"が取り出される
```
| 特徴 | キュー操作 (FIFO) | スタック操作 (LIFO) |
| --- | --- | --- |
| 構造の定義 | 先入れ先出し<br>First In, First Out | 後入れ先出し<br>Last In, First Out |
| 典型的な用途 | タスクの順序処理<br>プリンだジョブ管理 | 処理の巻き戻し<br>関数コールスタック |
| 要素の追加要素 | `offer(e)` または<br>`add(e)`後端に追加 | `push(e)`先端に追加 |
| 要素の削除方法 | `poll()` または<br>`remove()`前端から削除 | `pop()`先端から削除 |
| 要素の参照方法 | `peek()`前端の要素を取得・削除しない | `peek()`先端の要素を取得、削除しない |
| 空のときの挙動 | `poll()` ⇒ nullを返す | `pop()` ⇒ NoSuchExceptionをスロー  |
| インターフェイス | `Queue`(Dequeを通じて実装可能) | `Deque`(Stackより推奨される) |
| 使用するメソッド例 | `add(e)`<br>`offer(e)`<br>`poll()`<br>`peek()` | `push(e)`<br>`pop()`<br>`peek()` |
| 実装の例	 | `PriorityQueue`<br>`LinkedList` | `ArrayDeque`<br>`Stack`(非推奨) |
| 適した場面 | 並列タスクの処理、<br>イベントの順序制御 | バックトラッキング、<br>DFS（深き優先探索） |

***************************************************************************
## Deque(デック)
* java.util.Deque(Queue インターフェイスを拡張)
* 両端キュー：両端から要素の追加・削除が可能

FIFOまたはLIFOの両方の動作をサポート
* **FIFO（First-In-First-Out）**：先に入れた要素が先に取り出される
* **LIFO 構造（Last In, First Out）**：後に入れた要素が先に取り出される
* **主な実装クラス**：
  * ArrayDeque：率的に両端の操作ができ、スタックやキューの操作に使える
  * LinkedList：デック操作も可能だが、主にリストとして使われることが多い

| 特徴 | ArrayDeque | LinkedList |
| --- | --- | --- |
| **順序** | 挿入順を保持 | 挿入順を保持 |
| **速度** | 高速（O(1)：両端操作） | 両端操作は O(1)<br>中央操作は O(n) |
| **メモリ効率** | 配列ベースでメモリ効率が良い | 要素ごとにノードを持つためオーバーヘッドが高い |
| **データ構造** | 動的配列 | 双方向リンクリスト |
| **使用場面** | 両端キュー、スタック操作が多い場合 | ランダムアクセスより挿入/削除が多い場合 |
| **サポート機能** | キュー（Queue）<br>スタック（Stack） | キュー（Queue）<br>Deque、リスト |

``` Java
Deque<Integer> deque = new ArrayDeque<>();
deque.addFirst(10);
deque.addLast(20);
deque.removeFirst();  // 10が取り出される
```

***************************************************************************
## Map(マップ)
* **キーと値のペアを格納するコレクション**：キーを使って値を格納し、キーで検索する  
順序や重複に関するルールは異なる
* **主な実装クラス**：
  * HashMap：順序を保証しない（キーのハッシュ値）、高速（O(1)）。順序が不要で高速な操作を求める場合
  * LinkedHashMap：**挿入順**を保持、少し遅い（O(1)に近い）。順序を維持したい場合
  * TreeMap：自然順序（または指定された比較順序）でキーを並べる、やや遅い（O(log n)）。キーに基づく順序が重要な場合

| 特徴 | HashMap | LinkedHashMap | TreeMap |
| --- | --- | --- | --- |
| **順序** | 順序を保証しない<br>キーのハッシュ値依存 | 挿入順を保持 | 自然順序または比較順序で保持 |
| **速度** | 高速（O(1)）| 少し遅い（O(1)に近い） | やや遅い（O(log n)） |
| **メモリ効率** | **配列**＋**ハッシュベース**でメモリ効率が高い | **配列**＋**ハッシュ**＋**リンク**のオーバーヘッドあり | **ツリーベース**でややメモリ消費が多い |
| **データ構造** | ハッシュテーブル | ハッシュテーブル＋双方向リンクリスト | 赤黒木（Red-Black Tree） |
| **使用場面** | 順序が不要で高速な操作 | 順序を維持したい場合 | キーに基づく順序が重要な場合 |
| **サポート機能** | 基本的なマップ操作のみ | 順序の保持（アクセス順 or 挿入順も選択可能） | ソートされた順序に基づく範囲クエリやナビゲーション |

概要
* [コレクション型とは](#コレクション型とは)
* [List(リスト)](#list(リスト))
* [Set(セット)](#set(セット))
* [Queue(キュー)](#queue(キュー))
* [Stack(スタック)](#stack(スタック))
* [Deque(デック)](#deque(デック))
* [Map(マップ)](#map(マップ))
***************************************************************************
## コレクション型とは
* コレクション型は、複数の要素を一つのオブジェクトとして管理できるデータ構造のこと
* Javaでは、これを管理するための`インターフェース`や`クラス`が `java.util` パッケージに提供されている
* コレクション型を使うことで、複数のデータを効率的に扱えるようになる
* コレクションを操作するために、Collections クラスやStream API（Java 8以降）が用意されている

| インターフェイス | 説明 | 主な実装クラス |
| --- | --- | --- |
| List | データ項目に順序付けしたコレクションで、順序付けて要素を管理する<br>リストの中の要素は重複しても良い | ArrayList<br>LinkedList<br>Vector |
| Set | ユニークな値のコレクションで、順不同で要素を管理する<br>重複した要素は管理できない | HashSet<br>LinkedHashSet<br>TreeSet |
| Queue | FIFO(First-In-First-Out)形式のデータ入出力を行うコレクション | ArrayDeque<br>LinkedList<br>PriorityQueue |
| Stack | LIFO(Last-In-First-Out)形式でデータ入出力を行うコレクション | Stack |
| Deque | 両端キューで、FIFOまたはLIFOで要素を操作できるコレクション | ArrayDeque<br>LinkedList |
| Map | 個々のキーに対応する値をマップしたオブジェクトで、1つのキーに一つの値が割り当てられる<br>マップの中でキーは重複できないが、値は重複できる | HashMap<br>LinkedHashMap<br>TreeMap |

***************************************************************************
## List(リスト)
* **順序付きのコレクション**：リストに格納された要素は挿入された順番を保持する
* **重複を許可**：同じ要素を何度でも格納できる
* **主な実装クラス**：
  * ArrayList：動的配列で、**ランダムアクセスが高速**、要素の挿入・削除は遅い場合がある
  * LinkedList：双方向リストで、挿入・削除が高速だが、ランダムアクセスは遅い
  * Vector：同期化された動的配列。古い実装で、現在ではあまり使われない
* その他実装クラス：
  * CopyOnWriteArrayList：読み取り操作が多い場合に最適なスレッドセーフなリスト
  * UnmodifiableList：読み取り専用のリスト
  * SynchronizedList：スレッドセーフなリスト
  * ImmutableList：外部ライブラリによる不変リスト

***************************************************************************
## Set(セット)
* **順序なし**
* **重複なし**：要素が順不同で格納され、重複する要素は格納できない
* **主な実装クラス**：
  * HashSet：ハッシュテーブルを使った実装で、**順序を保証しない**が、高速
  * LinkedHashSet：順序を保持し、**挿入順**に要素が格納される
  * TreeSet：木構造を使った実装で、要素が**自然順序**（**比較順序**）で格納される

***************************************************************************
## Queue(キュー)
* **FIFO（First-In-First-Out）**：先に入れた要素が先に取り出される
* **主な実装クラス**：
  * LinkedList（Queueインターフェースの実装）
  * PriorityQueue：要素に優先度を設定して、最も**優先度の高い要素を最初に取り出す**

```Java
Queue<String> queue = new LinkedList<>();
queue.add("Apple");
queue.add("Banana");
queue.poll();  // "Apple"が取り出される
```

***************************************************************************
## Stack(スタック)
* **LIFO 構造（Last In, First Out）**：後に入れた要素が先に取り出される
* **主な実装クラス**：
  * Stack：従来のスタック実装クラス。後入れ先出しのデータ構造
  * ArrayDeque：Dequeとしても使えるため、スタック操作に適している

```Java
Stack<String> stack = new Stack<>();
stack.push("Apple");
stack.push("Banana");
stack.pop();  // "Banana"が取り出される
```

***************************************************************************
## Deque(デック)
* java.util.Deque(Queue インターフェイスを拡張)
* 両端キュー：両端から要素の追加・削除が可能

FIFOまたはLIFOの両方の動作をサポート
* **FIFO（First-In-First-Out）**：先に入れた要素が先に取り出される
* **LIFO 構造（Last In, First Out）**：後に入れた要素が先に取り出される
* **主な実装クラス**：
  * ArrayDeque：率的に両端の操作ができ、スタックやキューの操作に使える
  * LinkedList：デック操作も可能だが、主にリストとして使われることが多い

``` Java
Deque<Integer> deque = new ArrayDeque<>();
deque.addFirst(10);
deque.addLast(20);
deque.removeFirst();  // 10が取り出される
```

***************************************************************************
## Map(マップ)
* **キーと値のペアを格納するコレクション**：キーを使って値を格納し、キーで検索する  
順序や重複に関するルールは異なる
* **主な実装クラス**：
  * HashMap：順序を保証せず、高速にアクセスできる
  * LinkedHashMap：**挿入順**を保持する
  * TreeMap：自然順序（または指定された比較順序）でキーを並べる



概要
* [ArrayDequeの特徴](#arraydequeの特徴)
* [主なコード一覧](#主なコード一覧)
  * [要素の追加](#要素の追加)
    * [先端に要素を追加](#先端に要素を追加)
    * [先端に要素を追加、エラー出る場合falseを返す](#先端に要素を追加エラー出る場合falseを返す)
    * [後端に要素を追加](#後端に要素を追加)
    * [後端に要素を追加、エラー出る場合falseを返す](#後端に要素を追加エラー出る場合falseを返す)
  * [削除](#削除)
    * [前端から要素を削除](#前端から要素を削除)
    * [前端から要素を削除、空の場合nullを返す](#前端から要素を削除空の場合nullを返す)
    * [後端から要素を削除](#後端から要素を削除)
    * [後端から要素を削除、空の場合nullを返す](#後端から要素を削除空の場合nullを返す)
  * [要素の取得](#要素の取得)
    * [前端の要素を取得(popしない)](#前端の要素を取得popしない)
    * [前端の要素を取得(popしない)、空の場合nullを返す](#前端の要素を取得popしない空の場合nullを返す)
    * [後端の要素を取得(popしない)](#後端の要素を取得popしない)
    * [後端の要素を取得(popしない)、空の場合nullを返す](#後端の要素を取得popしない空の場合nullを返す)

なお、便宜を図って、各型のデフォ値を下記通りとする。  
`ArrayDeque<String>` deque = new ArrayDeque<>();　または  
`ArrayDeque<Integer>` deque = new ArrayDeque<>();

***************************************************************************
## ArrayDequeの特徴
* **java.util.ArrayDeque;**
* **実装インターフェース**：
  * Deque(Queueのサブインターフェイス)
  * Iterable
  * Collection
* **動作**：
  * 配列をベースとした実装で、要素を前後どちらの端からも効率的に追加・削除できる
  * **リングバッファ（循環配列）**のように動作します。配列が満杯になると容量を動的に拡張する
* **両端操作可能**
  * キュー（FIFO）としてもスタック（LIFO）としても利用できる
* **高効率**
  * 要素の追加や削除はほぼ定数時間（O(1)）で行える
  * 内部的には動的配列であるため、要素数に応じて容量が自動的に拡張
* **スレッドセーフではない**
  * 高速化のため、スレッドセーフの機能はない　⇒　そのため、シングルスレッドのシナリオに最適
  * マルチスレッド環境では、必要に応じて外部で同期を取る必要がある
* **ArrayDequeではnull要素を格納できない**
* **宣言と初期化**
```Java
// 空の ArrayDeque を生成（デフォルトの初期容量）
ArrayDeque<Integer> deque = new ArrayDeque<>();

// 初期容量を指定して生成（要素数が多い場合に便利）
ArrayDeque<String> deque = new ArrayDeque<>(32);

// 初期要素付きで生成する（Arrays.asListを使う）import java.util.Arrays;も必要となる
ArrayDeque<String> fruits = new ArrayDeque<>(Arrays.asList("Apple", "Banana", "Cherry"));

// リストをデックに変える
ArrayDeque<Integer> deque = new ArrayDeque<>(li);
```

***************************************************************************
## 主なコード一覧

### 要素の追加
#### 先端に要素を追加
* deque.addFirst(x);
* deque.push(x);　⇒　スタック操作 (LIFO)

#### 先端に要素を追加、エラー出る場合falseを返す
deque.offerFirst(x);

#### 後端に要素を追加
deque.addLast(x);

#### 後端に要素を追加、エラー出る場合falseを返す
deque.offerLast(x);

***************************************************************************
### 削除
#### 前端から要素を削除
* deque.removeFirst();
* deque.pop();　⇒　キュー操作 (FIFO)
* deque.poll();　⇒　スタック操作 (LIFO)

※ 空の場合エラー出る

#### 前端から要素を削除、空の場合nullを返す
deque.pollFirst();

#### 後端から要素を削除
deque.removeLast();  
※ 空の場合エラー出る

#### 後端から要素を削除、空の場合nullを返す
deque.pollLast();

***************************************************************************
### 要素の取得
#### 前端の要素を取得(popしない)
* deque.getFirst();
* deque.peek();

#### 前端の要素を取得(popしない)、空の場合nullを返す
deque.peekFirst();

#### 後端の要素を取得(popしない)
deque.getLast();

#### 後端の要素を取得(popしない)、空の場合nullを返す
deque.peekLast();
